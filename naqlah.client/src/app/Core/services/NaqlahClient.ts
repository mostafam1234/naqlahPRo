//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class Client {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    postRegister(registration?: RegisterRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registration);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostRegister(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postLogin(login?: LoginRequest | undefined, useCookies?: boolean | null | undefined, useSessionCookies?: boolean | null | undefined): Observable<AccessTokenResponse> {
        let url_ = this.baseUrl + "/login?";
        if (useCookies !== undefined && useCookies !== null)
            url_ += "useCookies=" + encodeURIComponent("" + useCookies) + "&";
        if (useSessionCookies !== undefined && useSessionCookies !== null)
            url_ += "useSessionCookies=" + encodeURIComponent("" + useSessionCookies) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccessTokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccessTokenResponse>;
        }));
    }

    protected processPostLogin(response: HttpResponseBase): Observable<AccessTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postRefresh(refreshRequest?: RefreshRequest | undefined): Observable<AccessTokenResponse> {
        let url_ = this.baseUrl + "/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(refreshRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostRefresh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostRefresh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccessTokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccessTokenResponse>;
        }));
    }

    protected processPostRefresh(response: HttpResponseBase): Observable<AccessTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getConfirmEmail(userId?: string | null | undefined, code?: string | null | undefined, changedEmail?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/confirmEmail?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (changedEmail !== undefined && changedEmail !== null)
            url_ += "changedEmail=" + encodeURIComponent("" + changedEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfirmEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfirmEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetConfirmEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postResendConfirmationEmail(resendRequest?: ResendConfirmationEmailRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/resendConfirmationEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resendRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostResendConfirmationEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostResendConfirmationEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostResendConfirmationEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postForgotPassword(resetRequest?: ForgotPasswordRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/forgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resetRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostForgotPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostForgotPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postResetPassword(resetRequest?: ResetPasswordRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/resetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resetRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postManage2fa(tfaRequest?: TwoFactorRequest | undefined): Observable<TwoFactorResponse> {
        let url_ = this.baseUrl + "/manage/2fa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tfaRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostManage2fa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostManage2fa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TwoFactorResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TwoFactorResponse>;
        }));
    }

    protected processPostManage2fa(response: HttpResponseBase): Observable<TwoFactorResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TwoFactorResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getManageInfo(): Observable<InfoResponse> {
        let url_ = this.baseUrl + "/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManageInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManageInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InfoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InfoResponse>;
        }));
    }

    protected processGetManageInfo(response: HttpResponseBase): Observable<InfoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InfoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postManageInfo(infoRequest?: InfoRequest | undefined): Observable<InfoResponse> {
        let url_ = this.baseUrl + "/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(infoRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostManageInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostManageInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InfoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InfoResponse>;
        }));
    }

    protected processPostManageInfo(response: HttpResponseBase): Observable<InfoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InfoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class WeatherForecastClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    get(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherForecast[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherForecast[]>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CustomerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    registerAsIndividual(registerRequest: IndividualCustomerRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/Customer/RegisterAsIndividual";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registerRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterAsIndividual(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterAsIndividual(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRegisterAsIndividual(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    regenerateActivationCode(request: RegenerateActivationCodeRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/Customer/RegenerateActivationCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegenerateActivationCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegenerateActivationCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRegenerateActivationCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getActivationCode(phoneNumber?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Customer/GetActivationCode?";
        if (phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' cannot be null.");
        else if (phoneNumber !== undefined)
            url_ += "phoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivationCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivationCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetActivationCode(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    activate(request: ActivationRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/Customer/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addDevices(request: DeliveryDeviceTokensDto): Observable<void> {
        let url_ = this.baseUrl + "/api/Customer/AddDevices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddDevices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddDevices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    logIn(request: LoginRquestDto): Observable<CustomerLoginResponse> {
        let url_ = this.baseUrl + "/api/Customer/LogIn";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogIn(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerLoginResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerLoginResponse>;
        }));
    }

    protected processLogIn(response: HttpResponseBase): Observable<CustomerLoginResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerLoginResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registerAsEstablishMent(registerRequest: EstablishMentCustomerRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/Customer/RegisterAsEstablishMent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registerRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterAsEstablishMent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterAsEstablishMent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRegisterAsEstablishMent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CustomerOrderClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(request: CreateOrderDto): Observable<CreateOrderResponseDto> {
        let url_ = this.baseUrl + "/api/CustomerOrder/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateOrderResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateOrderResponseDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateOrderResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrderResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    selectVehicleType(request: SelectVehicleTypeDto): Observable<SelectVehicleTypeResponseDto> {
        let url_ = this.baseUrl + "/api/CustomerOrder/SelectVehicleType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectVehicleType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectVehicleType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectVehicleTypeResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectVehicleTypeResponseDto>;
        }));
    }

    protected processSelectVehicleType(response: HttpResponseBase): Observable<SelectVehicleTypeResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectVehicleTypeResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMyOrders(pageNumber?: number | undefined, pageSize?: number | undefined, statusFilter?: OrderStatus | null | undefined, fromDate?: Date | null | undefined, toDate?: Date | null | undefined): Observable<PagedCustomerOrdersDto> {
        let url_ = this.baseUrl + "/api/CustomerOrder/GetMyOrders?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (statusFilter !== undefined && statusFilter !== null)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedCustomerOrdersDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedCustomerOrdersDto>;
        }));
    }

    protected processGetMyOrders(response: HttpResponseBase): Observable<PagedCustomerOrdersDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedCustomerOrdersDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrderDetails(orderId: number): Observable<OrderDetailsDto> {
        let url_ = this.baseUrl + "/api/CustomerOrder/GetOrderDetails/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDetailsDto>;
        }));
    }

    protected processGetOrderDetails(response: HttpResponseBase): Observable<OrderDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAssistantWorks(): Observable<AssistantWorkDto[]> {
        let url_ = this.baseUrl + "/api/CustomerOrder/GetAssistantWorks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssistantWorks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssistantWorks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssistantWorkDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssistantWorkDto[]>;
        }));
    }

    protected processGetAssistantWorks(response: HttpResponseBase): Observable<AssistantWorkDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssistantWorkDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CustomerWalletClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getBalance(customerId: number): Observable<CustomerWalletBalanceDto> {
        let url_ = this.baseUrl + "/api/CustomerWallet/GetBalance/{customerId}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerWalletBalanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerWalletBalanceDto>;
        }));
    }

    protected processGetBalance(response: HttpResponseBase): Observable<CustomerWalletBalanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerWalletBalanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DeliveryManClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    register(registerRequest: DeliveryRegisterRequest): Observable<DeliveryManTokenResponse> {
        let url_ = this.baseUrl + "/api/DeliveryMan/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registerRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeliveryManTokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeliveryManTokenResponse>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<DeliveryManTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeliveryManTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    active(request: ChangeDeliverManActiationRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/DeliveryMan/Active";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActive(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveLocation(request: DeliveryManLocationRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/DeliveryMan/SaveLocation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveLocation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveLocation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    logIn(registerRequest: LoginRquestDto): Observable<DeliveryManTokenResponse> {
        let url_ = this.baseUrl + "/api/DeliveryMan/LogIn";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registerRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogIn(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeliveryManTokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeliveryManTokenResponse>;
        }));
    }

    protected processLogIn(response: HttpResponseBase): Observable<DeliveryManTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeliveryManTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    assistant(request: AddAssistantRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/DeliveryMan/Assistant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssistant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssistant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssistant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addDeviceTokens(request: DeliveryDeviceTokensDto): Observable<void> {
        let url_ = this.baseUrl + "/api/DeliveryMan/AddDeviceTokens";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddDeviceTokens(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddDeviceTokens(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddDeviceTokens(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeDeviceTokens(request: DeliveryDeviceTokensDto): Observable<void> {
        let url_ = this.baseUrl + "/api/DeliveryMan/RemoveDeviceTokens";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveDeviceTokens(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveDeviceTokens(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveDeviceTokens(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    info(): Observable<DeliveryManInfoDto> {
        let url_ = this.baseUrl + "/api/DeliveryMan/Info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeliveryManInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeliveryManInfoDto>;
        }));
    }

    protected processInfo(response: HttpResponseBase): Observable<DeliveryManInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeliveryManInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    maidTypes(): Observable<MaidTypeDto[]> {
        let url_ = this.baseUrl + "/api/DeliveryMan/MaidTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMaidTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMaidTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MaidTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MaidTypeDto[]>;
        }));
    }

    protected processMaidTypes(response: HttpResponseBase): Observable<MaidTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MaidTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createPersonalInfo(request: DeliveryPersonalInfoRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/DeliveryMan/CreatePersonalInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePersonalInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePersonalInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreatePersonalInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addCarOwnerResidentInfo(request: ResidentRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/DeliveryMan/AddCarOwnerResidentInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCarOwnerResidentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCarOwnerResidentInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddCarOwnerResidentInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addCarOwnerCompanyInfo(request: CompanyRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/DeliveryMan/AddCarOwnerCompanyInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCarOwnerCompanyInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCarOwnerCompanyInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddCarOwnerCompanyInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addCarOwnerRenterInfo(request: RenterRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/DeliveryMan/AddCarOwnerRenterInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCarOwnerRenterInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCarOwnerRenterInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddCarOwnerRenterInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addVehicle(request: AddDeliveryVehicleRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/DeliveryMan/AddVehicle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddVehicle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddVehicle(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddVehicle(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    vehicleBrands(): Observable<VehicleBrandDto[]> {
        let url_ = this.baseUrl + "/api/DeliveryMan/VehicleBrands";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVehicleBrands(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVehicleBrands(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleBrandDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleBrandDto[]>;
        }));
    }

    protected processVehicleBrands(response: HttpResponseBase): Observable<VehicleBrandDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VehicleBrandDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    vehicleTypes(): Observable<VehicleTypeDto[]> {
        let url_ = this.baseUrl + "/api/DeliveryMan/VehicleTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVehicleTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVehicleTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehicleTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehicleTypeDto[]>;
        }));
    }

    protected processVehicleTypes(response: HttpResponseBase): Observable<VehicleTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VehicleTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DeliveryOrderClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getPendingOrdersWithinRadius(): Observable<PendingOrderDto[]> {
        let url_ = this.baseUrl + "/api/DeliveryOrder/GetPendingOrdersWithinRadius";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPendingOrdersWithinRadius(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPendingOrdersWithinRadius(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PendingOrderDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PendingOrderDto[]>;
        }));
    }

    protected processGetPendingOrdersWithinRadius(response: HttpResponseBase): Observable<PendingOrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PendingOrderDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    assignOrder(request: AssignOrderRequestDto): Observable<boolean> {
        let url_ = this.baseUrl + "/api/DeliveryOrder/AssignOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processAssignOrder(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrderDetails(orderId: number): Observable<OrderDetailsResponse> {
        let url_ = this.baseUrl + "/api/DeliveryOrder/GetOrderDetails/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderDetailsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderDetailsResponse>;
        }));
    }

    protected processGetOrderDetails(response: HttpResponseBase): Observable<OrderDetailsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDetailsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    changeWayPointStatus(request: ChangeWayPointStatusRequestDto): Observable<void> {
        let url_ = this.baseUrl + "/api/DeliveryOrder/ChangeWayPointStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeWayPointStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeWayPointStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeWayPointStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class MainCategoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getActiveCategories(): Observable<ActiveCategoryDto[]> {
        let url_ = this.baseUrl + "/api/MainCategory/GetActiveCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActiveCategoryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActiveCategoryDto[]>;
        }));
    }

    protected processGetActiveCategories(response: HttpResponseBase): Observable<ActiveCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ActiveCategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OrderPackClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(): Observable<OrderPackDto[]> {
        let url_ = this.baseUrl + "/api/OrderPack/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderPackDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderPackDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<OrderPackDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderPackDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class RegionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getOrderRegions(): Observable<RegionDto[]> {
        let url_ = this.baseUrl + "/api/Region/GetOrderRegions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderRegions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderRegions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegionDto[]>;
        }));
    }

    protected processGetOrderRegions(response: HttpResponseBase): Observable<RegionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RegionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetail.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ProblemDetails {
    type!: string | null;
    title!: string | null;
    status!: number | null;
    detail!: string | null;
    instance!: string | null;

    [key: string]: any;

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.detail = _data["detail"] !== undefined ? _data["detail"] : <any>null;
            this.instance = _data["instance"] !== undefined ? _data["instance"] : <any>null;
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["detail"] = this.detail !== undefined ? this.detail : <any>null;
        data["instance"] = this.instance !== undefined ? this.instance : <any>null;
        return data;
    }
}

export class HttpValidationProblemDetails extends ProblemDetails {
    errors!: { [key: string]: string[]; };

    [key: string]: any;

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
            else {
                this.errors = <any>null;
            }
        }
    }

    static override fromJS(data: any): HttpValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new HttpValidationProblemDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = this.errors[key] !== undefined ? this.errors[key] : <any>null;
            }
        }
        super.toJSON(data);
        return data;
    }
}

export class RegisterRequest {
    email!: string;
    password!: string;

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export class AccessTokenResponse {
    tokenType!: string;
    accessToken!: string;
    expiresIn!: number;
    refreshToken!: string;

    init(_data?: any) {
        if (_data) {
            this.tokenType = _data["tokenType"] !== undefined ? _data["tokenType"] : <any>null;
            this.accessToken = _data["accessToken"] !== undefined ? _data["accessToken"] : <any>null;
            this.expiresIn = _data["expiresIn"] !== undefined ? _data["expiresIn"] : <any>null;
            this.refreshToken = _data["refreshToken"] !== undefined ? _data["refreshToken"] : <any>null;
        }
    }

    static fromJS(data: any): AccessTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccessTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tokenType"] = this.tokenType !== undefined ? this.tokenType : <any>null;
        data["accessToken"] = this.accessToken !== undefined ? this.accessToken : <any>null;
        data["expiresIn"] = this.expiresIn !== undefined ? this.expiresIn : <any>null;
        data["refreshToken"] = this.refreshToken !== undefined ? this.refreshToken : <any>null;
        return data;
    }
}

export class LoginRequest {
    email!: string;
    password!: string;
    twoFactorCode!: string | null;
    twoFactorRecoveryCode!: string | null;

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.twoFactorCode = _data["twoFactorCode"] !== undefined ? _data["twoFactorCode"] : <any>null;
            this.twoFactorRecoveryCode = _data["twoFactorRecoveryCode"] !== undefined ? _data["twoFactorRecoveryCode"] : <any>null;
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["twoFactorCode"] = this.twoFactorCode !== undefined ? this.twoFactorCode : <any>null;
        data["twoFactorRecoveryCode"] = this.twoFactorRecoveryCode !== undefined ? this.twoFactorRecoveryCode : <any>null;
        return data;
    }
}

export class RefreshRequest {
    refreshToken!: string;

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"] !== undefined ? _data["refreshToken"] : <any>null;
        }
    }

    static fromJS(data: any): RefreshRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken !== undefined ? this.refreshToken : <any>null;
        return data;
    }
}

export class ResendConfirmationEmailRequest {
    email!: string;

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
        }
    }

    static fromJS(data: any): ResendConfirmationEmailRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResendConfirmationEmailRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        return data;
    }
}

export class ForgotPasswordRequest {
    email!: string;

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
        }
    }

    static fromJS(data: any): ForgotPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        return data;
    }
}

export class ResetPasswordRequest {
    email!: string;
    resetCode!: string;
    newPassword!: string;

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.resetCode = _data["resetCode"] !== undefined ? _data["resetCode"] : <any>null;
            this.newPassword = _data["newPassword"] !== undefined ? _data["newPassword"] : <any>null;
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["resetCode"] = this.resetCode !== undefined ? this.resetCode : <any>null;
        data["newPassword"] = this.newPassword !== undefined ? this.newPassword : <any>null;
        return data;
    }
}

export class TwoFactorResponse {
    sharedKey!: string;
    recoveryCodesLeft!: number;
    recoveryCodes!: string[] | null;
    isTwoFactorEnabled!: boolean;
    isMachineRemembered!: boolean;

    init(_data?: any) {
        if (_data) {
            this.sharedKey = _data["sharedKey"] !== undefined ? _data["sharedKey"] : <any>null;
            this.recoveryCodesLeft = _data["recoveryCodesLeft"] !== undefined ? _data["recoveryCodesLeft"] : <any>null;
            if (Array.isArray(_data["recoveryCodes"])) {
                this.recoveryCodes = [] as any;
                for (let item of _data["recoveryCodes"])
                    this.recoveryCodes!.push(item);
            }
            else {
                this.recoveryCodes = <any>null;
            }
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"] !== undefined ? _data["isTwoFactorEnabled"] : <any>null;
            this.isMachineRemembered = _data["isMachineRemembered"] !== undefined ? _data["isMachineRemembered"] : <any>null;
        }
    }

    static fromJS(data: any): TwoFactorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sharedKey"] = this.sharedKey !== undefined ? this.sharedKey : <any>null;
        data["recoveryCodesLeft"] = this.recoveryCodesLeft !== undefined ? this.recoveryCodesLeft : <any>null;
        if (Array.isArray(this.recoveryCodes)) {
            data["recoveryCodes"] = [];
            for (let item of this.recoveryCodes)
                data["recoveryCodes"].push(item);
        }
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled !== undefined ? this.isTwoFactorEnabled : <any>null;
        data["isMachineRemembered"] = this.isMachineRemembered !== undefined ? this.isMachineRemembered : <any>null;
        return data;
    }
}

export class TwoFactorRequest {
    enable!: boolean | null;
    twoFactorCode!: string | null;
    resetSharedKey!: boolean;
    resetRecoveryCodes!: boolean;
    forgetMachine!: boolean;

    init(_data?: any) {
        if (_data) {
            this.enable = _data["enable"] !== undefined ? _data["enable"] : <any>null;
            this.twoFactorCode = _data["twoFactorCode"] !== undefined ? _data["twoFactorCode"] : <any>null;
            this.resetSharedKey = _data["resetSharedKey"] !== undefined ? _data["resetSharedKey"] : <any>null;
            this.resetRecoveryCodes = _data["resetRecoveryCodes"] !== undefined ? _data["resetRecoveryCodes"] : <any>null;
            this.forgetMachine = _data["forgetMachine"] !== undefined ? _data["forgetMachine"] : <any>null;
        }
    }

    static fromJS(data: any): TwoFactorRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enable"] = this.enable !== undefined ? this.enable : <any>null;
        data["twoFactorCode"] = this.twoFactorCode !== undefined ? this.twoFactorCode : <any>null;
        data["resetSharedKey"] = this.resetSharedKey !== undefined ? this.resetSharedKey : <any>null;
        data["resetRecoveryCodes"] = this.resetRecoveryCodes !== undefined ? this.resetRecoveryCodes : <any>null;
        data["forgetMachine"] = this.forgetMachine !== undefined ? this.forgetMachine : <any>null;
        return data;
    }
}

export class InfoResponse {
    email!: string;
    isEmailConfirmed!: boolean;

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.isEmailConfirmed = _data["isEmailConfirmed"] !== undefined ? _data["isEmailConfirmed"] : <any>null;
        }
    }

    static fromJS(data: any): InfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new InfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["isEmailConfirmed"] = this.isEmailConfirmed !== undefined ? this.isEmailConfirmed : <any>null;
        return data;
    }
}

export class InfoRequest {
    newEmail!: string | null;
    newPassword!: string | null;
    oldPassword!: string | null;

    init(_data?: any) {
        if (_data) {
            this.newEmail = _data["newEmail"] !== undefined ? _data["newEmail"] : <any>null;
            this.newPassword = _data["newPassword"] !== undefined ? _data["newPassword"] : <any>null;
            this.oldPassword = _data["oldPassword"] !== undefined ? _data["oldPassword"] : <any>null;
        }
    }

    static fromJS(data: any): InfoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new InfoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newEmail"] = this.newEmail !== undefined ? this.newEmail : <any>null;
        data["newPassword"] = this.newPassword !== undefined ? this.newPassword : <any>null;
        data["oldPassword"] = this.oldPassword !== undefined ? this.oldPassword : <any>null;
        return data;
    }
}

export class WeatherForecast {
    date!: Date;
    temperatureC!: number;
    temperatureF!: number;
    summary!: string | null;

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>null;
            this.temperatureC = _data["temperatureC"] !== undefined ? _data["temperatureC"] : <any>null;
            this.temperatureF = _data["temperatureF"] !== undefined ? _data["temperatureF"] : <any>null;
            this.summary = _data["summary"] !== undefined ? _data["summary"] : <any>null;
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? formatDate(this.date) : <any>null;
        data["temperatureC"] = this.temperatureC !== undefined ? this.temperatureC : <any>null;
        data["temperatureF"] = this.temperatureF !== undefined ? this.temperatureF : <any>null;
        data["summary"] = this.summary !== undefined ? this.summary : <any>null;
        return data;
    }
}

export class ProblemDetail {
    statusCode!: number;
    errorMessage!: string;
    additioanlData!: any;

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"] !== undefined ? _data["statusCode"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
            this.additioanlData = _data["additioanlData"] !== undefined ? _data["additioanlData"] : <any>null;
        }
    }

    static fromJS(data: any): ProblemDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode !== undefined ? this.statusCode : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        data["additioanlData"] = this.additioanlData !== undefined ? this.additioanlData : <any>null;
        return data;
    }
}

export class IndividualCustomerRequest {
    phoneNumber!: string;
    identityNumber!: string;
    frontIdentityImage!: string;
    backIdentityImage!: string;
    password!: string;

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.identityNumber = _data["identityNumber"] !== undefined ? _data["identityNumber"] : <any>null;
            this.frontIdentityImage = _data["frontIdentityImage"] !== undefined ? _data["frontIdentityImage"] : <any>null;
            this.backIdentityImage = _data["backIdentityImage"] !== undefined ? _data["backIdentityImage"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): IndividualCustomerRequest {
        data = typeof data === 'object' ? data : {};
        let result = new IndividualCustomerRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["identityNumber"] = this.identityNumber !== undefined ? this.identityNumber : <any>null;
        data["frontIdentityImage"] = this.frontIdentityImage !== undefined ? this.frontIdentityImage : <any>null;
        data["backIdentityImage"] = this.backIdentityImage !== undefined ? this.backIdentityImage : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export class RegenerateActivationCodeRequest {
    phoneNumber!: string;

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
        }
    }

    static fromJS(data: any): RegenerateActivationCodeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegenerateActivationCodeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        return data;
    }
}

export class ActivationRequest {
    phoneNumber!: string;
    activeCode!: string;

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.activeCode = _data["activeCode"] !== undefined ? _data["activeCode"] : <any>null;
        }
    }

    static fromJS(data: any): ActivationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ActivationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["activeCode"] = this.activeCode !== undefined ? this.activeCode : <any>null;
        return data;
    }
}

export class DeliveryDeviceTokensDto {
    andriodDevice!: string;
    iosDevice!: string;

    init(_data?: any) {
        if (_data) {
            this.andriodDevice = _data["andriodDevice"] !== undefined ? _data["andriodDevice"] : <any>null;
            this.iosDevice = _data["iosDevice"] !== undefined ? _data["iosDevice"] : <any>null;
        }
    }

    static fromJS(data: any): DeliveryDeviceTokensDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeliveryDeviceTokensDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["andriodDevice"] = this.andriodDevice !== undefined ? this.andriodDevice : <any>null;
        data["iosDevice"] = this.iosDevice !== undefined ? this.iosDevice : <any>null;
        return data;
    }
}

export class CustomerLoginResponse {
    isActive!: boolean;
    tokenResponse!: TokenResponse;

    init(_data?: any) {
        if (_data) {
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.tokenResponse = _data["tokenResponse"] ? TokenResponse.fromJS(_data["tokenResponse"]) : <any>null;
        }
    }

    static fromJS(data: any): CustomerLoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerLoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["tokenResponse"] = this.tokenResponse ? this.tokenResponse.toJSON() : <any>null;
        return data;
    }
}

export class TokenResponse {
    accessToken!: string;
    expiresIn!: number;
    refreshToken!: string;

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"] !== undefined ? _data["accessToken"] : <any>null;
            this.expiresIn = _data["expiresIn"] !== undefined ? _data["expiresIn"] : <any>null;
            this.refreshToken = _data["refreshToken"] !== undefined ? _data["refreshToken"] : <any>null;
        }
    }

    static fromJS(data: any): TokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken !== undefined ? this.accessToken : <any>null;
        data["expiresIn"] = this.expiresIn !== undefined ? this.expiresIn : <any>null;
        data["refreshToken"] = this.refreshToken !== undefined ? this.refreshToken : <any>null;
        return data;
    }
}

export class LoginRquestDto {
    userName!: string;
    password!: string;

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): LoginRquestDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRquestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export class EstablishMentCustomerRequest {
    name!: string;
    mobileNumber!: string;
    recoredImage!: string;
    taxRegistrationNumber!: string;
    taxRegistrationImage!: string;
    address!: string;
    representitveName!: string;
    representitvePhoneNumber!: string;
    representitveFrontIdentityNumberImage!: string;
    representitveBackIdentityNumberImage!: string;
    password!: string;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.mobileNumber = _data["mobileNumber"] !== undefined ? _data["mobileNumber"] : <any>null;
            this.recoredImage = _data["recoredImage"] !== undefined ? _data["recoredImage"] : <any>null;
            this.taxRegistrationNumber = _data["taxRegistrationNumber"] !== undefined ? _data["taxRegistrationNumber"] : <any>null;
            this.taxRegistrationImage = _data["taxRegistrationImage"] !== undefined ? _data["taxRegistrationImage"] : <any>null;
            this.address = _data["address"] !== undefined ? _data["address"] : <any>null;
            this.representitveName = _data["representitveName"] !== undefined ? _data["representitveName"] : <any>null;
            this.representitvePhoneNumber = _data["representitvePhoneNumber"] !== undefined ? _data["representitvePhoneNumber"] : <any>null;
            this.representitveFrontIdentityNumberImage = _data["representitveFrontIdentityNumberImage"] !== undefined ? _data["representitveFrontIdentityNumberImage"] : <any>null;
            this.representitveBackIdentityNumberImage = _data["representitveBackIdentityNumberImage"] !== undefined ? _data["representitveBackIdentityNumberImage"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): EstablishMentCustomerRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EstablishMentCustomerRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["mobileNumber"] = this.mobileNumber !== undefined ? this.mobileNumber : <any>null;
        data["recoredImage"] = this.recoredImage !== undefined ? this.recoredImage : <any>null;
        data["taxRegistrationNumber"] = this.taxRegistrationNumber !== undefined ? this.taxRegistrationNumber : <any>null;
        data["taxRegistrationImage"] = this.taxRegistrationImage !== undefined ? this.taxRegistrationImage : <any>null;
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["representitveName"] = this.representitveName !== undefined ? this.representitveName : <any>null;
        data["representitvePhoneNumber"] = this.representitvePhoneNumber !== undefined ? this.representitvePhoneNumber : <any>null;
        data["representitveFrontIdentityNumberImage"] = this.representitveFrontIdentityNumberImage !== undefined ? this.representitveFrontIdentityNumberImage : <any>null;
        data["representitveBackIdentityNumberImage"] = this.representitveBackIdentityNumberImage !== undefined ? this.representitveBackIdentityNumberImage : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export class CreateOrderResponseDto {
    orderId!: number;
    matchingVehicles!: VehicleDto[];

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"] !== undefined ? _data["orderId"] : <any>null;
            if (Array.isArray(_data["matchingVehicles"])) {
                this.matchingVehicles = [] as any;
                for (let item of _data["matchingVehicles"])
                    this.matchingVehicles!.push(VehicleDto.fromJS(item));
            }
            else {
                this.matchingVehicles = <any>null;
            }
        }
    }

    static fromJS(data: any): CreateOrderResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        if (Array.isArray(this.matchingVehicles)) {
            data["matchingVehicles"] = [];
            for (let item of this.matchingVehicles)
                data["matchingVehicles"].push(item.toJSON());
        }
        return data;
    }
}

export class VehicleDto {
    id!: number;
    name!: string;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): VehicleDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export class CreateOrderDto {
    orderPackId!: number;
    orderTypeId!: number;
    mainCategoryIds!: number[];
    orderServiceIds!: number[];
    wayPoints!: CreateWayPointsDto[];

    init(_data?: any) {
        if (_data) {
            this.orderPackId = _data["orderPackId"] !== undefined ? _data["orderPackId"] : <any>null;
            this.orderTypeId = _data["orderTypeId"] !== undefined ? _data["orderTypeId"] : <any>null;
            if (Array.isArray(_data["mainCategoryIds"])) {
                this.mainCategoryIds = [] as any;
                for (let item of _data["mainCategoryIds"])
                    this.mainCategoryIds!.push(item);
            }
            else {
                this.mainCategoryIds = <any>null;
            }
            if (Array.isArray(_data["orderServiceIds"])) {
                this.orderServiceIds = [] as any;
                for (let item of _data["orderServiceIds"])
                    this.orderServiceIds!.push(item);
            }
            else {
                this.orderServiceIds = <any>null;
            }
            if (Array.isArray(_data["wayPoints"])) {
                this.wayPoints = [] as any;
                for (let item of _data["wayPoints"])
                    this.wayPoints!.push(CreateWayPointsDto.fromJS(item));
            }
            else {
                this.wayPoints = <any>null;
            }
        }
    }

    static fromJS(data: any): CreateOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderPackId"] = this.orderPackId !== undefined ? this.orderPackId : <any>null;
        data["orderTypeId"] = this.orderTypeId !== undefined ? this.orderTypeId : <any>null;
        if (Array.isArray(this.mainCategoryIds)) {
            data["mainCategoryIds"] = [];
            for (let item of this.mainCategoryIds)
                data["mainCategoryIds"].push(item);
        }
        if (Array.isArray(this.orderServiceIds)) {
            data["orderServiceIds"] = [];
            for (let item of this.orderServiceIds)
                data["orderServiceIds"].push(item);
        }
        if (Array.isArray(this.wayPoints)) {
            data["wayPoints"] = [];
            for (let item of this.wayPoints)
                data["wayPoints"].push(item.toJSON());
        }
        return data;
    }
}

export class CreateWayPointsDto {
    latitude!: number;
    longitude!: number;
    regionId!: number;
    cityId!: number;
    neighborhoodId!: number;
    isOrgin!: boolean;
    isDestenation!: boolean;

    init(_data?: any) {
        if (_data) {
            this.latitude = _data["latitude"] !== undefined ? _data["latitude"] : <any>null;
            this.longitude = _data["longitude"] !== undefined ? _data["longitude"] : <any>null;
            this.regionId = _data["regionId"] !== undefined ? _data["regionId"] : <any>null;
            this.cityId = _data["cityId"] !== undefined ? _data["cityId"] : <any>null;
            this.neighborhoodId = _data["neighborhoodId"] !== undefined ? _data["neighborhoodId"] : <any>null;
            this.isOrgin = _data["isOrgin"] !== undefined ? _data["isOrgin"] : <any>null;
            this.isDestenation = _data["isDestenation"] !== undefined ? _data["isDestenation"] : <any>null;
        }
    }

    static fromJS(data: any): CreateWayPointsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWayPointsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["regionId"] = this.regionId !== undefined ? this.regionId : <any>null;
        data["cityId"] = this.cityId !== undefined ? this.cityId : <any>null;
        data["neighborhoodId"] = this.neighborhoodId !== undefined ? this.neighborhoodId : <any>null;
        data["isOrgin"] = this.isOrgin !== undefined ? this.isOrgin : <any>null;
        data["isDestenation"] = this.isDestenation !== undefined ? this.isDestenation : <any>null;
        return data;
    }
}

export class SelectVehicleTypeResponseDto {
    success!: boolean;
    message!: string;
    notifiedDeliveryMenCount!: number;

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.notifiedDeliveryMenCount = _data["notifiedDeliveryMenCount"] !== undefined ? _data["notifiedDeliveryMenCount"] : <any>null;
        }
    }

    static fromJS(data: any): SelectVehicleTypeResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectVehicleTypeResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["notifiedDeliveryMenCount"] = this.notifiedDeliveryMenCount !== undefined ? this.notifiedDeliveryMenCount : <any>null;
        return data;
    }
}

export class SelectVehicleTypeDto {
    orderId!: number;
    vehicleTypeId!: number;

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"] !== undefined ? _data["orderId"] : <any>null;
            this.vehicleTypeId = _data["vehicleTypeId"] !== undefined ? _data["vehicleTypeId"] : <any>null;
        }
    }

    static fromJS(data: any): SelectVehicleTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SelectVehicleTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        data["vehicleTypeId"] = this.vehicleTypeId !== undefined ? this.vehicleTypeId : <any>null;
        return data;
    }
}

export class PagedCustomerOrdersDto {
    orders!: CustomerOrderListDto[];
    totalCount!: number;
    pageNumber!: number;
    pageSize!: number;
    totalPages!: number;
    hasNextPage!: boolean;
    hasPreviousPage!: boolean;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["orders"])) {
                this.orders = [] as any;
                for (let item of _data["orders"])
                    this.orders!.push(CustomerOrderListDto.fromJS(item));
            }
            else {
                this.orders = <any>null;
            }
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            this.pageNumber = _data["pageNumber"] !== undefined ? _data["pageNumber"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.totalPages = _data["totalPages"] !== undefined ? _data["totalPages"] : <any>null;
            this.hasNextPage = _data["hasNextPage"] !== undefined ? _data["hasNextPage"] : <any>null;
            this.hasPreviousPage = _data["hasPreviousPage"] !== undefined ? _data["hasPreviousPage"] : <any>null;
        }
    }

    static fromJS(data: any): PagedCustomerOrdersDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedCustomerOrdersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.orders)) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        data["pageNumber"] = this.pageNumber !== undefined ? this.pageNumber : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["totalPages"] = this.totalPages !== undefined ? this.totalPages : <any>null;
        data["hasNextPage"] = this.hasNextPage !== undefined ? this.hasNextPage : <any>null;
        data["hasPreviousPage"] = this.hasPreviousPage !== undefined ? this.hasPreviousPage : <any>null;
        return data;
    }
}

export class CustomerOrderListDto {
    id!: number;
    orderNumber!: string;
    createdDate!: Date;
    status!: OrderStatus;
    statusName!: string;
    total!: number;
    deliveryManName!: string;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.orderNumber = _data["orderNumber"] !== undefined ? _data["orderNumber"] : <any>null;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.statusName = _data["statusName"] !== undefined ? _data["statusName"] : <any>null;
            this.total = _data["total"] !== undefined ? _data["total"] : <any>null;
            this.deliveryManName = _data["deliveryManName"] !== undefined ? _data["deliveryManName"] : <any>null;
        }
    }

    static fromJS(data: any): CustomerOrderListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerOrderListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["orderNumber"] = this.orderNumber !== undefined ? this.orderNumber : <any>null;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["statusName"] = this.statusName !== undefined ? this.statusName : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        data["deliveryManName"] = this.deliveryManName !== undefined ? this.deliveryManName : <any>null;
        return data;
    }
}

export enum OrderStatus {
    Pending = 1,
    Assigned = 2,
    Cancelled = 3,
    Completed = 4,
}

export class OrderDetailsDto {
    id!: number;
    orderNumber!: string;
    createdDate!: Date;
    status!: OrderStatus;
    statusName!: string;
    total!: number;
    orderType!: OrderType;
    orderTypeName!: string;
    vehicleTypeId!: number | null;
    vehicleTypeName!: string;
    deliveryManId!: number | null;
    deliveryManName!: string;
    deliveryManPhone!: string;
    packageName!: string;
    categories!: OrderCategoryDto[];
    services!: OrderServiceDto[];
    wayPoints!: OrderWayPointDto[];
    paymentMethods!: OrderPaymentMethodDto[];

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.orderNumber = _data["orderNumber"] !== undefined ? _data["orderNumber"] : <any>null;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.statusName = _data["statusName"] !== undefined ? _data["statusName"] : <any>null;
            this.total = _data["total"] !== undefined ? _data["total"] : <any>null;
            this.orderType = _data["orderType"] !== undefined ? _data["orderType"] : <any>null;
            this.orderTypeName = _data["orderTypeName"] !== undefined ? _data["orderTypeName"] : <any>null;
            this.vehicleTypeId = _data["vehicleTypeId"] !== undefined ? _data["vehicleTypeId"] : <any>null;
            this.vehicleTypeName = _data["vehicleTypeName"] !== undefined ? _data["vehicleTypeName"] : <any>null;
            this.deliveryManId = _data["deliveryManId"] !== undefined ? _data["deliveryManId"] : <any>null;
            this.deliveryManName = _data["deliveryManName"] !== undefined ? _data["deliveryManName"] : <any>null;
            this.deliveryManPhone = _data["deliveryManPhone"] !== undefined ? _data["deliveryManPhone"] : <any>null;
            this.packageName = _data["packageName"] !== undefined ? _data["packageName"] : <any>null;
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(OrderCategoryDto.fromJS(item));
            }
            else {
                this.categories = <any>null;
            }
            if (Array.isArray(_data["services"])) {
                this.services = [] as any;
                for (let item of _data["services"])
                    this.services!.push(OrderServiceDto.fromJS(item));
            }
            else {
                this.services = <any>null;
            }
            if (Array.isArray(_data["wayPoints"])) {
                this.wayPoints = [] as any;
                for (let item of _data["wayPoints"])
                    this.wayPoints!.push(OrderWayPointDto.fromJS(item));
            }
            else {
                this.wayPoints = <any>null;
            }
            if (Array.isArray(_data["paymentMethods"])) {
                this.paymentMethods = [] as any;
                for (let item of _data["paymentMethods"])
                    this.paymentMethods!.push(OrderPaymentMethodDto.fromJS(item));
            }
            else {
                this.paymentMethods = <any>null;
            }
        }
    }

    static fromJS(data: any): OrderDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["orderNumber"] = this.orderNumber !== undefined ? this.orderNumber : <any>null;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["statusName"] = this.statusName !== undefined ? this.statusName : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        data["orderType"] = this.orderType !== undefined ? this.orderType : <any>null;
        data["orderTypeName"] = this.orderTypeName !== undefined ? this.orderTypeName : <any>null;
        data["vehicleTypeId"] = this.vehicleTypeId !== undefined ? this.vehicleTypeId : <any>null;
        data["vehicleTypeName"] = this.vehicleTypeName !== undefined ? this.vehicleTypeName : <any>null;
        data["deliveryManId"] = this.deliveryManId !== undefined ? this.deliveryManId : <any>null;
        data["deliveryManName"] = this.deliveryManName !== undefined ? this.deliveryManName : <any>null;
        data["deliveryManPhone"] = this.deliveryManPhone !== undefined ? this.deliveryManPhone : <any>null;
        data["packageName"] = this.packageName !== undefined ? this.packageName : <any>null;
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        if (Array.isArray(this.services)) {
            data["services"] = [];
            for (let item of this.services)
                data["services"].push(item.toJSON());
        }
        if (Array.isArray(this.wayPoints)) {
            data["wayPoints"] = [];
            for (let item of this.wayPoints)
                data["wayPoints"].push(item.toJSON());
        }
        if (Array.isArray(this.paymentMethods)) {
            data["paymentMethods"] = [];
            for (let item of this.paymentMethods)
                data["paymentMethods"].push(item.toJSON());
        }
        return data;
    }
}

export enum OrderType {
    SingleWayPoints = 1,
    MultiWayPoints = 2,
    BackAndForth = 3,
}

export class OrderCategoryDto {
    categoryId!: number;
    categoryName!: string;

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.categoryName = _data["categoryName"] !== undefined ? _data["categoryName"] : <any>null;
        }
    }

    static fromJS(data: any): OrderCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["categoryName"] = this.categoryName !== undefined ? this.categoryName : <any>null;
        return data;
    }
}

export class OrderServiceDto {
    serviceId!: number;
    serviceName!: string;
    amount!: number;

    init(_data?: any) {
        if (_data) {
            this.serviceId = _data["serviceId"] !== undefined ? _data["serviceId"] : <any>null;
            this.serviceName = _data["serviceName"] !== undefined ? _data["serviceName"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
        }
    }

    static fromJS(data: any): OrderServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceId"] = this.serviceId !== undefined ? this.serviceId : <any>null;
        data["serviceName"] = this.serviceName !== undefined ? this.serviceName : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        return data;
    }
}

export class OrderWayPointDto {
    id!: number;
    latitude!: number;
    longitude!: number;
    isOrigin!: boolean;
    isDestination!: boolean;
    status!: OrderWayPointsStatus;
    statusName!: string;
    pickedUpDate!: Date | null;
    address!: string;
    regionName!: string;
    cityName!: string;
    neighborhoodName!: string;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.latitude = _data["latitude"] !== undefined ? _data["latitude"] : <any>null;
            this.longitude = _data["longitude"] !== undefined ? _data["longitude"] : <any>null;
            this.isOrigin = _data["isOrigin"] !== undefined ? _data["isOrigin"] : <any>null;
            this.isDestination = _data["isDestination"] !== undefined ? _data["isDestination"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.statusName = _data["statusName"] !== undefined ? _data["statusName"] : <any>null;
            this.pickedUpDate = _data["pickedUpDate"] ? new Date(_data["pickedUpDate"].toString()) : <any>null;
            this.address = _data["address"] !== undefined ? _data["address"] : <any>null;
            this.regionName = _data["regionName"] !== undefined ? _data["regionName"] : <any>null;
            this.cityName = _data["cityName"] !== undefined ? _data["cityName"] : <any>null;
            this.neighborhoodName = _data["neighborhoodName"] !== undefined ? _data["neighborhoodName"] : <any>null;
        }
    }

    static fromJS(data: any): OrderWayPointDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderWayPointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["isOrigin"] = this.isOrigin !== undefined ? this.isOrigin : <any>null;
        data["isDestination"] = this.isDestination !== undefined ? this.isDestination : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["statusName"] = this.statusName !== undefined ? this.statusName : <any>null;
        data["pickedUpDate"] = this.pickedUpDate ? this.pickedUpDate.toISOString() : <any>null;
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["regionName"] = this.regionName !== undefined ? this.regionName : <any>null;
        data["cityName"] = this.cityName !== undefined ? this.cityName : <any>null;
        data["neighborhoodName"] = this.neighborhoodName !== undefined ? this.neighborhoodName : <any>null;
        return data;
    }
}

export enum OrderWayPointsStatus {
    Pending = 1,
    PickedUp = 2,
    Completed = 3,
}

export class OrderPaymentMethodDto {
    paymentMethodId!: number;
    paymentMethodName!: string;
    amount!: number;

    init(_data?: any) {
        if (_data) {
            this.paymentMethodId = _data["paymentMethodId"] !== undefined ? _data["paymentMethodId"] : <any>null;
            this.paymentMethodName = _data["paymentMethodName"] !== undefined ? _data["paymentMethodName"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
        }
    }

    static fromJS(data: any): OrderPaymentMethodDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderPaymentMethodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentMethodId"] = this.paymentMethodId !== undefined ? this.paymentMethodId : <any>null;
        data["paymentMethodName"] = this.paymentMethodName !== undefined ? this.paymentMethodName : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        return data;
    }
}

export class AssistantWorkDto {
    id!: number;
    name!: string;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): AssistantWorkDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssistantWorkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export class CustomerWalletBalanceDto {
    customerId!: number;
    balance!: number;
    transactionCount!: number;

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["customerId"] !== undefined ? _data["customerId"] : <any>null;
            this.balance = _data["balance"] !== undefined ? _data["balance"] : <any>null;
            this.transactionCount = _data["transactionCount"] !== undefined ? _data["transactionCount"] : <any>null;
        }
    }

    static fromJS(data: any): CustomerWalletBalanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerWalletBalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId !== undefined ? this.customerId : <any>null;
        data["balance"] = this.balance !== undefined ? this.balance : <any>null;
        data["transactionCount"] = this.transactionCount !== undefined ? this.transactionCount : <any>null;
        return data;
    }
}

export class DeliveryManTokenResponse {
    tokenResponse!: TokenResponse;
    requiredCarOwnerInfo!: boolean;
    requiredPersonalInfo!: boolean;
    requiredVehicleInfo!: boolean;
    carOwnerType!: number | null;

    init(_data?: any) {
        if (_data) {
            this.tokenResponse = _data["tokenResponse"] ? TokenResponse.fromJS(_data["tokenResponse"]) : <any>null;
            this.requiredCarOwnerInfo = _data["requiredCarOwnerInfo"] !== undefined ? _data["requiredCarOwnerInfo"] : <any>null;
            this.requiredPersonalInfo = _data["requiredPersonalInfo"] !== undefined ? _data["requiredPersonalInfo"] : <any>null;
            this.requiredVehicleInfo = _data["requiredVehicleInfo"] !== undefined ? _data["requiredVehicleInfo"] : <any>null;
            this.carOwnerType = _data["carOwnerType"] !== undefined ? _data["carOwnerType"] : <any>null;
        }
    }

    static fromJS(data: any): DeliveryManTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DeliveryManTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tokenResponse"] = this.tokenResponse ? this.tokenResponse.toJSON() : <any>null;
        data["requiredCarOwnerInfo"] = this.requiredCarOwnerInfo !== undefined ? this.requiredCarOwnerInfo : <any>null;
        data["requiredPersonalInfo"] = this.requiredPersonalInfo !== undefined ? this.requiredPersonalInfo : <any>null;
        data["requiredVehicleInfo"] = this.requiredVehicleInfo !== undefined ? this.requiredVehicleInfo : <any>null;
        data["carOwnerType"] = this.carOwnerType !== undefined ? this.carOwnerType : <any>null;
        return data;
    }
}

export class DeliveryRegisterRequest {
    name!: string;
    phoneNumber!: string;
    email!: string;
    password!: string;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): DeliveryRegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeliveryRegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export class ChangeDeliverManActiationRequest {
    active!: boolean;

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
        }
    }

    static fromJS(data: any): ChangeDeliverManActiationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeDeliverManActiationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active !== undefined ? this.active : <any>null;
        return data;
    }
}

export class DeliveryManLocationRequest {
    longitude!: number;
    latitude!: number;

    init(_data?: any) {
        if (_data) {
            this.longitude = _data["longitude"] !== undefined ? _data["longitude"] : <any>null;
            this.latitude = _data["latitude"] !== undefined ? _data["latitude"] : <any>null;
        }
    }

    static fromJS(data: any): DeliveryManLocationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeliveryManLocationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        return data;
    }
}

export class AddAssistantRequest {
    name!: string;
    phone!: string;
    address!: string;
    identityNumber!: string;
    frontIdentityImage!: string;
    backIdentityImage!: string;
    identityExpirationDate!: string;
    maidTypeId!: number;

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.phone = _data["phone"] !== undefined ? _data["phone"] : <any>null;
            this.address = _data["address"] !== undefined ? _data["address"] : <any>null;
            this.identityNumber = _data["identityNumber"] !== undefined ? _data["identityNumber"] : <any>null;
            this.frontIdentityImage = _data["frontIdentityImage"] !== undefined ? _data["frontIdentityImage"] : <any>null;
            this.backIdentityImage = _data["backIdentityImage"] !== undefined ? _data["backIdentityImage"] : <any>null;
            this.identityExpirationDate = _data["identityExpirationDate"] !== undefined ? _data["identityExpirationDate"] : <any>null;
            this.maidTypeId = _data["maidTypeId"] !== undefined ? _data["maidTypeId"] : <any>null;
        }
    }

    static fromJS(data: any): AddAssistantRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddAssistantRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["identityNumber"] = this.identityNumber !== undefined ? this.identityNumber : <any>null;
        data["frontIdentityImage"] = this.frontIdentityImage !== undefined ? this.frontIdentityImage : <any>null;
        data["backIdentityImage"] = this.backIdentityImage !== undefined ? this.backIdentityImage : <any>null;
        data["identityExpirationDate"] = this.identityExpirationDate !== undefined ? this.identityExpirationDate : <any>null;
        data["maidTypeId"] = this.maidTypeId !== undefined ? this.maidTypeId : <any>null;
        return data;
    }
}

export class DeliveryManInfoDto {
    id!: number;
    name!: string;
    phoneNumber!: string;
    personalImagePath!: string;
    active!: boolean;
    chatUrl!: string;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
            this.personalImagePath = _data["personalImagePath"] !== undefined ? _data["personalImagePath"] : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.chatUrl = _data["chatUrl"] !== undefined ? _data["chatUrl"] : <any>null;
        }
    }

    static fromJS(data: any): DeliveryManInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeliveryManInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        data["personalImagePath"] = this.personalImagePath !== undefined ? this.personalImagePath : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["chatUrl"] = this.chatUrl !== undefined ? this.chatUrl : <any>null;
        return data;
    }
}

export class MaidTypeDto {
    id!: number;
    name!: string;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): MaidTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaidTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export class DeliveryPersonalInfoRequest {
    fullName!: string;
    address!: string;
    identityNumber!: string;
    frontIdenitytImage!: string;
    backIdenitytImage!: string;
    personalImage!: string;
    identityExpirationDate!: string;
    drivingLicenseExpirationDate!: string;
    deliveryTypeId!: number;
    deliveryLicenseTypeId!: number;
    frontDrivingLicenseImage!: string;
    backDrivingLicenseImage!: string;

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"] !== undefined ? _data["fullName"] : <any>null;
            this.address = _data["address"] !== undefined ? _data["address"] : <any>null;
            this.identityNumber = _data["identityNumber"] !== undefined ? _data["identityNumber"] : <any>null;
            this.frontIdenitytImage = _data["frontIdenitytImage"] !== undefined ? _data["frontIdenitytImage"] : <any>null;
            this.backIdenitytImage = _data["backIdenitytImage"] !== undefined ? _data["backIdenitytImage"] : <any>null;
            this.personalImage = _data["personalImage"] !== undefined ? _data["personalImage"] : <any>null;
            this.identityExpirationDate = _data["identityExpirationDate"] !== undefined ? _data["identityExpirationDate"] : <any>null;
            this.drivingLicenseExpirationDate = _data["drivingLicenseExpirationDate"] !== undefined ? _data["drivingLicenseExpirationDate"] : <any>null;
            this.deliveryTypeId = _data["deliveryTypeId"] !== undefined ? _data["deliveryTypeId"] : <any>null;
            this.deliveryLicenseTypeId = _data["deliveryLicenseTypeId"] !== undefined ? _data["deliveryLicenseTypeId"] : <any>null;
            this.frontDrivingLicenseImage = _data["frontDrivingLicenseImage"] !== undefined ? _data["frontDrivingLicenseImage"] : <any>null;
            this.backDrivingLicenseImage = _data["backDrivingLicenseImage"] !== undefined ? _data["backDrivingLicenseImage"] : <any>null;
        }
    }

    static fromJS(data: any): DeliveryPersonalInfoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeliveryPersonalInfoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["identityNumber"] = this.identityNumber !== undefined ? this.identityNumber : <any>null;
        data["frontIdenitytImage"] = this.frontIdenitytImage !== undefined ? this.frontIdenitytImage : <any>null;
        data["backIdenitytImage"] = this.backIdenitytImage !== undefined ? this.backIdenitytImage : <any>null;
        data["personalImage"] = this.personalImage !== undefined ? this.personalImage : <any>null;
        data["identityExpirationDate"] = this.identityExpirationDate !== undefined ? this.identityExpirationDate : <any>null;
        data["drivingLicenseExpirationDate"] = this.drivingLicenseExpirationDate !== undefined ? this.drivingLicenseExpirationDate : <any>null;
        data["deliveryTypeId"] = this.deliveryTypeId !== undefined ? this.deliveryTypeId : <any>null;
        data["deliveryLicenseTypeId"] = this.deliveryLicenseTypeId !== undefined ? this.deliveryLicenseTypeId : <any>null;
        data["frontDrivingLicenseImage"] = this.frontDrivingLicenseImage !== undefined ? this.frontDrivingLicenseImage : <any>null;
        data["backDrivingLicenseImage"] = this.backDrivingLicenseImage !== undefined ? this.backDrivingLicenseImage : <any>null;
        return data;
    }
}

export class ResidentRequest {
    citizenName!: string;
    identityNumber!: string;
    frontIdentityImage!: string;
    backIdentityImage!: string;
    bankAccountNumber!: string;

    init(_data?: any) {
        if (_data) {
            this.citizenName = _data["citizenName"] !== undefined ? _data["citizenName"] : <any>null;
            this.identityNumber = _data["identityNumber"] !== undefined ? _data["identityNumber"] : <any>null;
            this.frontIdentityImage = _data["frontIdentityImage"] !== undefined ? _data["frontIdentityImage"] : <any>null;
            this.backIdentityImage = _data["backIdentityImage"] !== undefined ? _data["backIdentityImage"] : <any>null;
            this.bankAccountNumber = _data["bankAccountNumber"] !== undefined ? _data["bankAccountNumber"] : <any>null;
        }
    }

    static fromJS(data: any): ResidentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResidentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["citizenName"] = this.citizenName !== undefined ? this.citizenName : <any>null;
        data["identityNumber"] = this.identityNumber !== undefined ? this.identityNumber : <any>null;
        data["frontIdentityImage"] = this.frontIdentityImage !== undefined ? this.frontIdentityImage : <any>null;
        data["backIdentityImage"] = this.backIdentityImage !== undefined ? this.backIdentityImage : <any>null;
        data["bankAccountNumber"] = this.bankAccountNumber !== undefined ? this.bankAccountNumber : <any>null;
        return data;
    }
}

export class CompanyRequest {
    companyName!: string;
    commercialRecordNumber!: string;
    recordImagePath!: string;
    taxNumber!: string;
    taxCertificateImage!: string;
    bankAccountNumber!: string;

    init(_data?: any) {
        if (_data) {
            this.companyName = _data["companyName"] !== undefined ? _data["companyName"] : <any>null;
            this.commercialRecordNumber = _data["commercialRecordNumber"] !== undefined ? _data["commercialRecordNumber"] : <any>null;
            this.recordImagePath = _data["recordImagePath"] !== undefined ? _data["recordImagePath"] : <any>null;
            this.taxNumber = _data["taxNumber"] !== undefined ? _data["taxNumber"] : <any>null;
            this.taxCertificateImage = _data["taxCertificateImage"] !== undefined ? _data["taxCertificateImage"] : <any>null;
            this.bankAccountNumber = _data["bankAccountNumber"] !== undefined ? _data["bankAccountNumber"] : <any>null;
        }
    }

    static fromJS(data: any): CompanyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName !== undefined ? this.companyName : <any>null;
        data["commercialRecordNumber"] = this.commercialRecordNumber !== undefined ? this.commercialRecordNumber : <any>null;
        data["recordImagePath"] = this.recordImagePath !== undefined ? this.recordImagePath : <any>null;
        data["taxNumber"] = this.taxNumber !== undefined ? this.taxNumber : <any>null;
        data["taxCertificateImage"] = this.taxCertificateImage !== undefined ? this.taxCertificateImage : <any>null;
        data["bankAccountNumber"] = this.bankAccountNumber !== undefined ? this.bankAccountNumber : <any>null;
        return data;
    }
}

export class RenterRequest {
    citizenName!: string;
    identityNumber!: string;
    frontIdentityImage!: string;
    backIdentityImage!: string;
    rentContractImage!: string;
    bankAccountNumber!: string;

    init(_data?: any) {
        if (_data) {
            this.citizenName = _data["citizenName"] !== undefined ? _data["citizenName"] : <any>null;
            this.identityNumber = _data["identityNumber"] !== undefined ? _data["identityNumber"] : <any>null;
            this.frontIdentityImage = _data["frontIdentityImage"] !== undefined ? _data["frontIdentityImage"] : <any>null;
            this.backIdentityImage = _data["backIdentityImage"] !== undefined ? _data["backIdentityImage"] : <any>null;
            this.rentContractImage = _data["rentContractImage"] !== undefined ? _data["rentContractImage"] : <any>null;
            this.bankAccountNumber = _data["bankAccountNumber"] !== undefined ? _data["bankAccountNumber"] : <any>null;
        }
    }

    static fromJS(data: any): RenterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RenterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["citizenName"] = this.citizenName !== undefined ? this.citizenName : <any>null;
        data["identityNumber"] = this.identityNumber !== undefined ? this.identityNumber : <any>null;
        data["frontIdentityImage"] = this.frontIdentityImage !== undefined ? this.frontIdentityImage : <any>null;
        data["backIdentityImage"] = this.backIdentityImage !== undefined ? this.backIdentityImage : <any>null;
        data["rentContractImage"] = this.rentContractImage !== undefined ? this.rentContractImage : <any>null;
        data["bankAccountNumber"] = this.bankAccountNumber !== undefined ? this.bankAccountNumber : <any>null;
        return data;
    }
}

export class AddDeliveryVehicleRequest {
    vehicleTypeId!: number;
    vehicleBrandId!: number;
    licensePlateNumber!: string;
    frontImagePath!: string;
    sideImagePath!: string;
    frontLicenseImagePath!: string;
    backLicenseImagePath!: string;
    licenseExpirationDate!: string;
    frontInsuranceImagePath!: string;
    backInsuranceImagePath!: string;
    inSuranceExpirationDate!: string;
    vehicleOwnerTypeId!: number;

    init(_data?: any) {
        if (_data) {
            this.vehicleTypeId = _data["vehicleTypeId"] !== undefined ? _data["vehicleTypeId"] : <any>null;
            this.vehicleBrandId = _data["vehicleBrandId"] !== undefined ? _data["vehicleBrandId"] : <any>null;
            this.licensePlateNumber = _data["licensePlateNumber"] !== undefined ? _data["licensePlateNumber"] : <any>null;
            this.frontImagePath = _data["frontImagePath"] !== undefined ? _data["frontImagePath"] : <any>null;
            this.sideImagePath = _data["sideImagePath"] !== undefined ? _data["sideImagePath"] : <any>null;
            this.frontLicenseImagePath = _data["frontLicenseImagePath"] !== undefined ? _data["frontLicenseImagePath"] : <any>null;
            this.backLicenseImagePath = _data["backLicenseImagePath"] !== undefined ? _data["backLicenseImagePath"] : <any>null;
            this.licenseExpirationDate = _data["licenseExpirationDate"] !== undefined ? _data["licenseExpirationDate"] : <any>null;
            this.frontInsuranceImagePath = _data["frontInsuranceImagePath"] !== undefined ? _data["frontInsuranceImagePath"] : <any>null;
            this.backInsuranceImagePath = _data["backInsuranceImagePath"] !== undefined ? _data["backInsuranceImagePath"] : <any>null;
            this.inSuranceExpirationDate = _data["inSuranceExpirationDate"] !== undefined ? _data["inSuranceExpirationDate"] : <any>null;
            this.vehicleOwnerTypeId = _data["vehicleOwnerTypeId"] !== undefined ? _data["vehicleOwnerTypeId"] : <any>null;
        }
    }

    static fromJS(data: any): AddDeliveryVehicleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddDeliveryVehicleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vehicleTypeId"] = this.vehicleTypeId !== undefined ? this.vehicleTypeId : <any>null;
        data["vehicleBrandId"] = this.vehicleBrandId !== undefined ? this.vehicleBrandId : <any>null;
        data["licensePlateNumber"] = this.licensePlateNumber !== undefined ? this.licensePlateNumber : <any>null;
        data["frontImagePath"] = this.frontImagePath !== undefined ? this.frontImagePath : <any>null;
        data["sideImagePath"] = this.sideImagePath !== undefined ? this.sideImagePath : <any>null;
        data["frontLicenseImagePath"] = this.frontLicenseImagePath !== undefined ? this.frontLicenseImagePath : <any>null;
        data["backLicenseImagePath"] = this.backLicenseImagePath !== undefined ? this.backLicenseImagePath : <any>null;
        data["licenseExpirationDate"] = this.licenseExpirationDate !== undefined ? this.licenseExpirationDate : <any>null;
        data["frontInsuranceImagePath"] = this.frontInsuranceImagePath !== undefined ? this.frontInsuranceImagePath : <any>null;
        data["backInsuranceImagePath"] = this.backInsuranceImagePath !== undefined ? this.backInsuranceImagePath : <any>null;
        data["inSuranceExpirationDate"] = this.inSuranceExpirationDate !== undefined ? this.inSuranceExpirationDate : <any>null;
        data["vehicleOwnerTypeId"] = this.vehicleOwnerTypeId !== undefined ? this.vehicleOwnerTypeId : <any>null;
        return data;
    }
}

export class VehicleBrandDto {
    id!: number;
    name!: string;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): VehicleBrandDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleBrandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export class VehicleTypeDto {
    id!: number;
    name!: string;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): VehicleTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export class PendingOrderDto {
    id!: number;
    orderNumber!: string;
    total!: number;
    distance!: number;
    pickupLatitude!: number;
    pickupLongitude!: number;
    deliveryLatitude!: number;
    deliveryLongitude!: number;
    pickupAddress!: string;
    deliveryAddress!: string;
    categories!: string[];
    createdAt!: Date;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.orderNumber = _data["orderNumber"] !== undefined ? _data["orderNumber"] : <any>null;
            this.total = _data["total"] !== undefined ? _data["total"] : <any>null;
            this.distance = _data["distance"] !== undefined ? _data["distance"] : <any>null;
            this.pickupLatitude = _data["pickupLatitude"] !== undefined ? _data["pickupLatitude"] : <any>null;
            this.pickupLongitude = _data["pickupLongitude"] !== undefined ? _data["pickupLongitude"] : <any>null;
            this.deliveryLatitude = _data["deliveryLatitude"] !== undefined ? _data["deliveryLatitude"] : <any>null;
            this.deliveryLongitude = _data["deliveryLongitude"] !== undefined ? _data["deliveryLongitude"] : <any>null;
            this.pickupAddress = _data["pickupAddress"] !== undefined ? _data["pickupAddress"] : <any>null;
            this.deliveryAddress = _data["deliveryAddress"] !== undefined ? _data["deliveryAddress"] : <any>null;
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(item);
            }
            else {
                this.categories = <any>null;
            }
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): PendingOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PendingOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["orderNumber"] = this.orderNumber !== undefined ? this.orderNumber : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        data["distance"] = this.distance !== undefined ? this.distance : <any>null;
        data["pickupLatitude"] = this.pickupLatitude !== undefined ? this.pickupLatitude : <any>null;
        data["pickupLongitude"] = this.pickupLongitude !== undefined ? this.pickupLongitude : <any>null;
        data["deliveryLatitude"] = this.deliveryLatitude !== undefined ? this.deliveryLatitude : <any>null;
        data["deliveryLongitude"] = this.deliveryLongitude !== undefined ? this.deliveryLongitude : <any>null;
        data["pickupAddress"] = this.pickupAddress !== undefined ? this.pickupAddress : <any>null;
        data["deliveryAddress"] = this.deliveryAddress !== undefined ? this.deliveryAddress : <any>null;
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item);
        }
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>null;
        return data;
    }
}

export class AssignOrderRequestDto {
    orderId!: number;

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"] !== undefined ? _data["orderId"] : <any>null;
        }
    }

    static fromJS(data: any): AssignOrderRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssignOrderRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        return data;
    }
}

export class OrderDetailsResponse {
    orderId!: number;
    orderNumber!: string;
    orderStatus!: OrderStatus;
    orderType!: OrderType;
    total!: number;
    customerId!: number;
    wayPoints!: OrderWayPointResponse[];
    orderDetails!: OrderDetailItemResponse[];
    orderServices!: OrderServiceResponse[];
    orderPackageArabicDescription!: string;
    orderPackageEnglishDescription!: string;
    paymentMethods!: PaymentMethodResponse[];

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"] !== undefined ? _data["orderId"] : <any>null;
            this.orderNumber = _data["orderNumber"] !== undefined ? _data["orderNumber"] : <any>null;
            this.orderStatus = _data["orderStatus"] !== undefined ? _data["orderStatus"] : <any>null;
            this.orderType = _data["orderType"] !== undefined ? _data["orderType"] : <any>null;
            this.total = _data["total"] !== undefined ? _data["total"] : <any>null;
            this.customerId = _data["customerId"] !== undefined ? _data["customerId"] : <any>null;
            if (Array.isArray(_data["wayPoints"])) {
                this.wayPoints = [] as any;
                for (let item of _data["wayPoints"])
                    this.wayPoints!.push(OrderWayPointResponse.fromJS(item));
            }
            else {
                this.wayPoints = <any>null;
            }
            if (Array.isArray(_data["orderDetails"])) {
                this.orderDetails = [] as any;
                for (let item of _data["orderDetails"])
                    this.orderDetails!.push(OrderDetailItemResponse.fromJS(item));
            }
            else {
                this.orderDetails = <any>null;
            }
            if (Array.isArray(_data["orderServices"])) {
                this.orderServices = [] as any;
                for (let item of _data["orderServices"])
                    this.orderServices!.push(OrderServiceResponse.fromJS(item));
            }
            else {
                this.orderServices = <any>null;
            }
            this.orderPackageArabicDescription = _data["orderPackageArabicDescription"] !== undefined ? _data["orderPackageArabicDescription"] : <any>null;
            this.orderPackageEnglishDescription = _data["orderPackageEnglishDescription"] !== undefined ? _data["orderPackageEnglishDescription"] : <any>null;
            if (Array.isArray(_data["paymentMethods"])) {
                this.paymentMethods = [] as any;
                for (let item of _data["paymentMethods"])
                    this.paymentMethods!.push(PaymentMethodResponse.fromJS(item));
            }
            else {
                this.paymentMethods = <any>null;
            }
        }
    }

    static fromJS(data: any): OrderDetailsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetailsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        data["orderNumber"] = this.orderNumber !== undefined ? this.orderNumber : <any>null;
        data["orderStatus"] = this.orderStatus !== undefined ? this.orderStatus : <any>null;
        data["orderType"] = this.orderType !== undefined ? this.orderType : <any>null;
        data["total"] = this.total !== undefined ? this.total : <any>null;
        data["customerId"] = this.customerId !== undefined ? this.customerId : <any>null;
        if (Array.isArray(this.wayPoints)) {
            data["wayPoints"] = [];
            for (let item of this.wayPoints)
                data["wayPoints"].push(item.toJSON());
        }
        if (Array.isArray(this.orderDetails)) {
            data["orderDetails"] = [];
            for (let item of this.orderDetails)
                data["orderDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.orderServices)) {
            data["orderServices"] = [];
            for (let item of this.orderServices)
                data["orderServices"].push(item.toJSON());
        }
        data["orderPackageArabicDescription"] = this.orderPackageArabicDescription !== undefined ? this.orderPackageArabicDescription : <any>null;
        data["orderPackageEnglishDescription"] = this.orderPackageEnglishDescription !== undefined ? this.orderPackageEnglishDescription : <any>null;
        if (Array.isArray(this.paymentMethods)) {
            data["paymentMethods"] = [];
            for (let item of this.paymentMethods)
                data["paymentMethods"].push(item.toJSON());
        }
        return data;
    }
}

export class OrderWayPointResponse {
    id!: number;
    latitude!: number;
    longitude!: number;
    status!: OrderWayPointsStatus;
    pickedUpDate!: Date | null;
    packImagePath!: string;
    isOrigin!: boolean;
    isDestination!: boolean;
    regionArabicName!: string;
    regionEnglishName!: string;
    cityArabicName!: string;
    cityEnglishName!: string;
    neighborhoodArabicName!: string;
    neighborhoodEnglishName!: string;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.latitude = _data["latitude"] !== undefined ? _data["latitude"] : <any>null;
            this.longitude = _data["longitude"] !== undefined ? _data["longitude"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.pickedUpDate = _data["pickedUpDate"] ? new Date(_data["pickedUpDate"].toString()) : <any>null;
            this.packImagePath = _data["packImagePath"] !== undefined ? _data["packImagePath"] : <any>null;
            this.isOrigin = _data["isOrigin"] !== undefined ? _data["isOrigin"] : <any>null;
            this.isDestination = _data["isDestination"] !== undefined ? _data["isDestination"] : <any>null;
            this.regionArabicName = _data["regionArabicName"] !== undefined ? _data["regionArabicName"] : <any>null;
            this.regionEnglishName = _data["regionEnglishName"] !== undefined ? _data["regionEnglishName"] : <any>null;
            this.cityArabicName = _data["cityArabicName"] !== undefined ? _data["cityArabicName"] : <any>null;
            this.cityEnglishName = _data["cityEnglishName"] !== undefined ? _data["cityEnglishName"] : <any>null;
            this.neighborhoodArabicName = _data["neighborhoodArabicName"] !== undefined ? _data["neighborhoodArabicName"] : <any>null;
            this.neighborhoodEnglishName = _data["neighborhoodEnglishName"] !== undefined ? _data["neighborhoodEnglishName"] : <any>null;
        }
    }

    static fromJS(data: any): OrderWayPointResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrderWayPointResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["latitude"] = this.latitude !== undefined ? this.latitude : <any>null;
        data["longitude"] = this.longitude !== undefined ? this.longitude : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["pickedUpDate"] = this.pickedUpDate ? this.pickedUpDate.toISOString() : <any>null;
        data["packImagePath"] = this.packImagePath !== undefined ? this.packImagePath : <any>null;
        data["isOrigin"] = this.isOrigin !== undefined ? this.isOrigin : <any>null;
        data["isDestination"] = this.isDestination !== undefined ? this.isDestination : <any>null;
        data["regionArabicName"] = this.regionArabicName !== undefined ? this.regionArabicName : <any>null;
        data["regionEnglishName"] = this.regionEnglishName !== undefined ? this.regionEnglishName : <any>null;
        data["cityArabicName"] = this.cityArabicName !== undefined ? this.cityArabicName : <any>null;
        data["cityEnglishName"] = this.cityEnglishName !== undefined ? this.cityEnglishName : <any>null;
        data["neighborhoodArabicName"] = this.neighborhoodArabicName !== undefined ? this.neighborhoodArabicName : <any>null;
        data["neighborhoodEnglishName"] = this.neighborhoodEnglishName !== undefined ? this.neighborhoodEnglishName : <any>null;
        return data;
    }
}

export class OrderDetailItemResponse {
    id!: number;
    mainCategoryId!: number;
    arabicCategoryName!: string;
    englishCategoryName!: string;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.mainCategoryId = _data["mainCategoryId"] !== undefined ? _data["mainCategoryId"] : <any>null;
            this.arabicCategoryName = _data["arabicCategoryName"] !== undefined ? _data["arabicCategoryName"] : <any>null;
            this.englishCategoryName = _data["englishCategoryName"] !== undefined ? _data["englishCategoryName"] : <any>null;
        }
    }

    static fromJS(data: any): OrderDetailItemResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetailItemResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["mainCategoryId"] = this.mainCategoryId !== undefined ? this.mainCategoryId : <any>null;
        data["arabicCategoryName"] = this.arabicCategoryName !== undefined ? this.arabicCategoryName : <any>null;
        data["englishCategoryName"] = this.englishCategoryName !== undefined ? this.englishCategoryName : <any>null;
        return data;
    }
}

export class OrderServiceResponse {
    id!: number;
    workId!: number;
    arabicName!: string;
    englishName!: string;
    amount!: number;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.workId = _data["workId"] !== undefined ? _data["workId"] : <any>null;
            this.arabicName = _data["arabicName"] !== undefined ? _data["arabicName"] : <any>null;
            this.englishName = _data["englishName"] !== undefined ? _data["englishName"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
        }
    }

    static fromJS(data: any): OrderServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OrderServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["workId"] = this.workId !== undefined ? this.workId : <any>null;
        data["arabicName"] = this.arabicName !== undefined ? this.arabicName : <any>null;
        data["englishName"] = this.englishName !== undefined ? this.englishName : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        return data;
    }
}

export class PaymentMethodResponse {
    paymentMethodId!: number;
    paymentMethodArabicName!: string;
    paymentMethodEnglishName!: string;
    amount!: number;

    init(_data?: any) {
        if (_data) {
            this.paymentMethodId = _data["paymentMethodId"] !== undefined ? _data["paymentMethodId"] : <any>null;
            this.paymentMethodArabicName = _data["paymentMethodArabicName"] !== undefined ? _data["paymentMethodArabicName"] : <any>null;
            this.paymentMethodEnglishName = _data["paymentMethodEnglishName"] !== undefined ? _data["paymentMethodEnglishName"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
        }
    }

    static fromJS(data: any): PaymentMethodResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentMethodId"] = this.paymentMethodId !== undefined ? this.paymentMethodId : <any>null;
        data["paymentMethodArabicName"] = this.paymentMethodArabicName !== undefined ? this.paymentMethodArabicName : <any>null;
        data["paymentMethodEnglishName"] = this.paymentMethodEnglishName !== undefined ? this.paymentMethodEnglishName : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        return data;
    }
}

export class ChangeWayPointStatusRequestDto {
    orderId!: number;
    wayPointId!: number;
    packImageBase64!: string;

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"] !== undefined ? _data["orderId"] : <any>null;
            this.wayPointId = _data["wayPointId"] !== undefined ? _data["wayPointId"] : <any>null;
            this.packImageBase64 = _data["packImageBase64"] !== undefined ? _data["packImageBase64"] : <any>null;
        }
    }

    static fromJS(data: any): ChangeWayPointStatusRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeWayPointStatusRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        data["wayPointId"] = this.wayPointId !== undefined ? this.wayPointId : <any>null;
        data["packImageBase64"] = this.packImageBase64 !== undefined ? this.packImageBase64 : <any>null;
        return data;
    }
}

export class ActiveCategoryDto {
    id!: number;
    name!: string;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): ActiveCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActiveCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export class OrderPackDto {
    id!: number;
    description!: string;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): OrderPackDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderPackDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export class RegionDto {
    id!: number;
    name!: string;
    cities!: CityDto[];

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["cities"])) {
                this.cities = [] as any;
                for (let item of _data["cities"])
                    this.cities!.push(CityDto.fromJS(item));
            }
            else {
                this.cities = <any>null;
            }
        }
    }

    static fromJS(data: any): RegionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.cities)) {
            data["cities"] = [];
            for (let item of this.cities)
                data["cities"].push(item.toJSON());
        }
        return data;
    }
}

export class CityDto {
    id!: number;
    regionId!: number;
    name!: string;
    neighborhoods!: NeighborhoodDto[];

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.regionId = _data["regionId"] !== undefined ? _data["regionId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["neighborhoods"])) {
                this.neighborhoods = [] as any;
                for (let item of _data["neighborhoods"])
                    this.neighborhoods!.push(NeighborhoodDto.fromJS(item));
            }
            else {
                this.neighborhoods = <any>null;
            }
        }
    }

    static fromJS(data: any): CityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["regionId"] = this.regionId !== undefined ? this.regionId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.neighborhoods)) {
            data["neighborhoods"] = [];
            for (let item of this.neighborhoods)
                data["neighborhoods"].push(item.toJSON());
        }
        return data;
    }
}

export class NeighborhoodDto {
    id!: number;
    cityId!: number;
    name!: string;

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.cityId = _data["cityId"] !== undefined ? _data["cityId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): NeighborhoodDto {
        data = typeof data === 'object' ? data : {};
        let result = new NeighborhoodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["cityId"] = this.cityId !== undefined ? this.cityId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}